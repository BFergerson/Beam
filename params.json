{"name":"Beam","tagline":"Client/Server & P2P Networking Library","body":"Beam is client/server and peer-to-peer compatible networking library. It provides the ability to create large network systems with ease using language-independent messaging protocols. With Beam you can create a server to handle many concurrent connections as well as connect clients to each other for P2P connections. Beam provides the ability for P2P connections through UDP hole punching and UPnP. Message serialization is currently performed by Google's Protocol Buffers (MessagePack and others will be available soon). \r\n\r\n## Overview ##\r\n* Creating a Server\r\n* Message Handlers\r\n* Connecting a Client\r\n* Creating Messages\r\n* Sending Messages\r\n* Exchanging Messages\r\n* Queuing Messages\r\n* Broadcasting Messages\r\n* Secure Communication\r\n\t* AES\r\n\t* RSA\r\n* P2P Connection\r\n\t* UPNP Connection\r\n\t* UDP Hole Punching\r\n\r\n\r\n## Creating a Server ##\r\nThis code starts a server on TCP port 45800\r\n```java\r\nBeamServer server = new BeamServer (45800);\r\nserver.start ();\r\n```\r\n\r\n## Message Handlers ##\r\n\r\nA Beam server works with message handlers. Each handler has the ability to accept one or more different types of messages\r\n\r\n```java\r\npublic class ExampleHandler extends BasicHandler\r\n{\r\n\r\n\tpublic ExampleHandler () {\r\n\t\tsuper (ExampleMessage.EXAMPLE_MESSAGE_ID);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic BeamMessage messageRecieved (Communicator comm, BasicMessage msg) {\r\n\t\tSystem.out.println (\"Client sent message: \" + msg.getString (\"client_message\"));\r\n\r\n\t\t//response message\r\n\t\treturn msg.emptyResponse ().setString (\"server_response\", \"example_reply_message\");\r\n\t}\r\n}\r\n```\r\n\r\nNote: Most handlers extend BeamHandler. BasicHandler is used in this example to allow for easier message manipulation.\r\n\r\nNow that you have created a handler you will need to add that handler to the server.\r\n```java\r\nserver.addHandler (ExampleHandler.class);\r\n```\r\n\r\nNote: Add handlers to server before starting to ensure it receives all messages.\r\n\r\n\r\n## Connecting a Client ##\r\n\r\nStarting a server creates a thread to handle incoming connections, reading/writing to the socket, and notifying handlers. Now that we have a server created and listening we will need to connect a client to it.\r\n\r\nThis code connects a client to a server at 127.0.0.1 on TCP port 45800\r\n\r\n```java\r\nBeamClient client = new BeamClient (127.0.0.1, 45800);\r\nclient.connect ();\r\n```\r\n\r\n## Creating Messages ##\r\n\r\n```java\r\npublic class ExampleMessage extends BasicMessage\r\n{\r\n\tpublic final static int EXAMPLE_MESSAGE_ID = 1000;\r\n\t\r\n\tpublic ExampleMessage () {\r\n\t\tsuper (EXAMPLE_MESSAGE_ID);\r\n\t}\r\n\r\n\tpublic ExampleMessage (BeamMessage message) {\r\n\t\tsuper (message);\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\nNote: Most messages extends BeamMessage. BasicMessage is being extending in this example to allow for easier message manipulation.\r\n\r\n## Sending Messages ##\r\n\r\nSending a message will send a message and block while waiting for a response.\r\n\r\nTo create and send a BasicMessage to the server from client\r\n```java\r\nExampleMessage exampleMessage = new ExampleMessage ();\r\nexampleMessage.setString (\"client_message\", \"example_client_message\");\r\nBeamMessage responseMessage = client.sendMessage (exampleMessage);\r\n\r\n//convert and output server response\r\nexampleMessage = new ExampleMessage (responseMessage);\r\nSystem.out.println (\"Server response: \" + exampleMessage.getString (\"server_response\"));\r\n```\r\n\r\n## Exchanging Messages ##\r\n\r\nExchanging a message will send a message and update the original message with the response message given. Useful when the request and response message are the same class as it avoids unnessecary casting like when sending messages.\r\n\r\nTo create and exchange a BasicMessage to the server from client\r\n```java\r\nExampleMessage exampleMessage = new ExampleMessage ();\r\nexampleMessage.setString (\"client_message\", \"example_client_message\");\r\nif (client.exchangeMessage (exampleMessage)) {\r\n\t//output server response\r\n\tSystem.out.println (exampleMessage.getString (\"server_response\"));\r\n} else {\r\n\tSystem.out.println (\"Request timed out!\");\r\n}\r\n```\r\n\r\n## Queuing Messages ##\r\n\r\nQueuing a message sends a message without waiting for a response.\r\n\r\nTo create and queue a BasicMessage to the server from client\r\n```java\r\nExampleMessage exampleMessage = new ExampleMessage ();\r\nexampleMessage.setString (\"client_message\", \"example_client_message\");\r\n\r\n//queue message. no need to wait for response\r\nclient.queueMessage (exampleMessage);\r\n```\r\n\r\n## Broadcasting Messages ##\r\n\r\nAs a server you can broadcast messages to all connected clients\r\n```java\r\nExampleMessage exampleMessage = new ExampleMessage ();\r\nexampleMessage.setString (\"example_broadcast\", \"test_value\");\r\n\r\nserver.broadcast (exampleMessage);\r\n```\r\n\r\n## Secure Communication ##\r\n\r\n### AES ####\r\n\r\nClient\r\n```java\r\nAES aes = new AES (\"password\");\r\nBeamMessage aesMessage = new AESBeamMessage (aes, ENCRYPTED_MESSAGE_ID);\r\naesMessage.set (\"secret_variable\", \"secret_value\");\r\n\r\n//send and receive response (response is returned decrypted)\r\nBeamMessage responseMessage = client.sendMessage (aesMessage);\r\nSystem.out.println (\"Server response: \" + responseMessage.get (\"server_response\");\r\n```\r\n\r\nServer\r\n```java\r\npublic class ExampleAESHandler extends AESBeamHandler\r\n{\r\n\r\n\tpublic ExampleAESHandler (AES aes) {\r\n\t\tsuper (aes, ENCRYPTED_MESSAGE_ID);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic BeamMessage messageRecieved (Communicator comm, BeamMessage message) {\r\n\t\tSystem.out.println (\"Client sent secret: \" + message.get (\"secret_variable\"));\r\n\r\n\t\tBasicMessage responseMessage = new BasicMessage (ENCRYPTED_MESSAGE_ID);\r\n\t\tresponseMessage.setString (\"server_response\", \"server_secret_value\");\r\n\t\treturn responseMessage;\r\n\t}\r\n\r\n}\r\n```\r\n\r\n### RSA ####\r\n\r\n\r\nClient\r\n```java\r\nRSA rsa = new RSA (1024);\r\nRSAConnection rsaConn = client.establishRSAConnection (rsa);\r\nBeamMessage rsaMessage = new RSABeamMessage (rsaConn, ENCRYPTED_MESSAGE_ID);\r\nrsaMessage.set (\"secret_variable\", \"secret_value\");\r\n\r\n//send and receive response (response is returned decrypted)\r\nBeamMessage responseMessage = client.sendMessage (rsaMessage);\r\nSystem.out.println (\"Server response: \" + responseMessage.get (\"server_response\");\r\n```\r\n\r\nServer\r\n```java\r\npublic class ExampleRSAHandler extends RSABeamHandler\r\n{\r\n\r\n\tpublic ExampleRSAHandler (RSA rsa) {\r\n\t\tsuper (ENCRYPTED_MESSAGE_ID);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic BeamMessage messageRecieved (Communicator comm, BeamMessage message) {\r\n\t\tSystem.out.println (\"Client sent secret: \" + message.get (\"secret_variable\"));\r\n\r\n\t\tBasicMessage responseMessage = new BasicMessage (ENCRYPTED_MESSAGE_ID);\r\n\t\tresponseMessage.setString (\"server_response\", \"server_secret_value\");\r\n\t\treturn responseMessage;\r\n\t}\r\n\r\n}\r\n```\r\n\r\nNote: Server must add a RSAHandshakeHandler with the private RSA\r\n```java\r\nserver.addRSAHandshakeHandler (new RSAHandshakeHandler (rsa));\r\n```\r\n\r\n## P2P Connection ##\r\n\r\n### UPNP Connection ###\r\n\r\nClient A\r\n```java\r\n//opens TCP port 45800 on Client A\r\nUPNPControl upnpControl = new UPNPControl (ConnectionProtocol.TCP);\r\nupnpControl.addPortMapping (\"Example UPNP Connection\", 45800, 45800);\r\n\r\n//receive message from Client B\r\nBeamMessage message = peerComm.fetchWithWait (Communicator.WAIT_FOREVER, EXAMPLE_UPNP_MESSAGE);\r\nBasicMessage basicMessage = new BasicMessage (message);\r\nSystem.out.println (\"Client B sent: \" + basicMessage.getString (\"client_message\"));\r\n\r\n//queue response to Client B\r\npeerComm.queue (basicMessage.emptyResponse ().setString (\"client_message\", \"Hello from Client A!\"));\r\n```\r\n\r\nClient B\r\n```java\r\n//connect to client A directly on port 45800 (which is open via UPNP)\r\nBeamClient client = new BeamClient (CLIENT_IP_ADDRESS, 45800);\r\nclient.connect ();\r\n\r\n//send message to Client A\r\nBasicMessage message = new BasicMessage (EXAMPLE_UPNP_MESSAGE);\r\nmessage.setString (\"client_message\", \"Hello from Client B!\");\r\nBeamMessage rtnMessage = peerComm.send (message);\r\n\r\n//convert and output Client A response\r\nmessage = new BasicMessage (rtnMessage);\r\nSystem.out.println (\"Client A sent: \" + basicMessage.getString (\"client_message\"));\r\n```\r\n\r\n### UDP Hole Punching ###\r\n\r\nClient A\r\n```java\r\nUDPHoleClient holeClient = new UDPHoleClient (PUNCH_SERVER_HOST, PUNCH_SERVER_PORT);\r\nCommunicator peerComm = holeClient.createHoleCommunicator (PEER_IDENTIFIER, PEER_ACCESS_CODE);\r\n\r\n//receive message from Client B\r\nBeamMessage message = peerComm.fetchWithWait (Communicator.WAIT_FOREVER, EXAMPLE_PUNCH_MESSAGE);\r\nBasicMessage basicMessage = new BasicMessage (message);\r\nSystem.out.println (\"Client B sent: \" + basicMessage.getString (\"client_message\"));\r\n\r\n//queue response to Client B\r\npeerComm.queue (basicMessage.emptyResponse ().setString (\"client_message\", \"Hello from Client A!\"));\r\n```\r\n\r\nClient B\r\n```java\r\nUDPPunchClient punchClient = new UDPPunchClient (PUNCH_SERVER_HOST, PUNCH_SERVER_PORT);\r\nCommunicator peerComm = punchClient.punchPeerCommunicator (PEER_IDENTIFIER, PEER_ACCESS_CODE);\r\n\r\nif (peerComm == null) {\r\n\tSystem.out.println (\"Could not find peer to connect to! Make sure peer is waiting with hole request...\");\r\n\treturn;\r\n}\r\n\r\n//send message to Client A\r\nBasicMessage message = new BasicMessage (TEST_PUNCH_MESSAGE_TYPE);\r\nmessage.setString (\"client_message\", \"Hello from Client B!\");\r\nBeamMessage rtnMessage = peerComm.send (message);\r\n\r\n//convert and output Client A response\r\nmessage = new BasicMessage (rtnMessage);\r\nSystem.out.println (\"Client A sent: \" + basicMessage.getString (\"client_message\"));\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}